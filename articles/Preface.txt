//title here

This is a preface for a series of articles about learning to write type-safe
wrapper libraries for legacy code. One of the main reasons for writing this is to
be used as a reference, not to forget why and how I did something. 
I learn as I go and am willing to share my experience would it be good 
or at least useful (in regards to show how NOT to do things). So feel free to 
criticize and add remarks in the comments. 

I know that it is hardly the first attempt to reinvent the wheel, and plenty of decent
libraries are available. However, there are a lot of people who feel an urge to do
things "the hard way" (obviously I am one of them), because "the hard way brings 
more exp", as many of us have learned playing RPG games (joking). 
But, seriously, not everyone would like to begin their learning of, for example, how 
computer graphics work with diving into some very popular, yet huge frameworks. 
For real life development it is essential to master one of them, however for the 
purpose of education/hobby/wasting time reimplementing existing approaches it is
useful to create libraries of your own.

//another title?

Going back to the initial intent: why another tutorial/public article, etc., when 
plenty of them have been around for ages already? 
Because I'd like to share some ideas of my own and have them gathered in one place. 
Because I want to try to create some modern C++ wrappers for legacy code, with little
or no (when possible) runtime overhead using templates.
Because (need to think about it).

Also, I will leave links to articles and tutorials which I found very useful
when I only started learning (and spent quite a bit of time looking for).

//title

What is it so bad about legacy code? 
Are you familiar with MS Windows API, ODBC, OpenGL? Then you know, what a nightmare
it is to read through the reference pages and try to understand the meaning for 
each of a million of strange function parameters. When some of them are "reserved" 
and "must always be 0", some force you to pass only a couple of acceptable values 
for one argument and accepting all the values for another one. When enums are 
represented by integers via MACRO definitions, alongside system Types.
And of course there are a bunch of error codes returned at runtime when invalid
arguments (types/enums/acceptable values) are used, which makes it a real pain 
to debug.
//example here

I suppose, the first thought to occur in one's head is "Why should it be allowed
in the first place, when we use a language with strong types like C++"? 
We can "easily" relief our brains from remembering where and which integer 
to pass (hence dealing with followed up debugging), if we simply define distinct 
types and enums for most cases and wrap legacy functions with type-safe ones.
There are at least to ways to achieve this:
1. Writing wrapping functions for each "type" (by hand or using some kind of generating).
2. Using templates. This means less code, but (not always necessarily) harder to maintain 
and understand.

I am for number 2 here.
It is simple, to wrap one function or a type, but of course it is far from
"easy" to write a sophisticated, reusable and elementary in usage template library, 
which meets its original goal - to make things easier.

See "Concepts.txt". (Will be updating)